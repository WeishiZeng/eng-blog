---
layout: post
title: 'Java Nested Class - (Original Post: Usage of java keyword "final" in Android)'
date: '2016-08-14T23:32:00.003-07:00'
author: Weishi Zeng
tags: engineering java
modified_time: '2018-04-18T20:47:58.878-07:00'
blogger_id: tag:blogger.com,1999:blog-3665547588863667471.post-3137989769298908676
blogger_orig_url: http://weishizeng.blogspot.com/2016/08/usage-of-java-keyword-final-in-android_98.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><h2 style="text-align: left;">Java Nested Class</h2><pre class="prettyprint">class OuterClass {<br />    ...<br />    static class StaticNestedClass {<br />        ...<br />    }<br />    class InnerClass {<br />        ...<br />    }<br />}</pre><h3 style="text-align: left;">1. Static Nested Class</h3><h4 style="text-align: left;"><b>Intuition</b>:</h4>Just like a top level class, nested for packaging convenience.<br /><h4 style="text-align: left;">Constructor:</h4><pre class="prettyprint" style="text-align: left;">OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();<br /></pre><h4 style="text-align: left;">Consequences:</h4>&nbsp; &nbsp; Enclosing Class Access:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can only direct access outer class static members. (Like any other class accessing OuterClass.java)<br />&nbsp; &nbsp; Members:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can define both static/non-static members. (members: fields + methods.)<br /><h4 style="text-align: left;">Usage:</h4><pre class="prettyprint">//like top-level class, more power to define, less power to access<br />static class StaticNestedClass {<br />    private Integer instanceField = 1;<br />    private static String staticField = outer_static_field;<br />    public static void staticMethod() {<br />        String a = outer_static_field;<br />    }<br />    public void instanceMethod() {<br />        String a = outer_static_field;<br />        //String b = outer_instance_field;  //ERROR: cannot reference non-static field<br />    }<br />}</pre><h3 style="text-align: left;">2. Inner Class</h3><h4 style="text-align: left;"><b>Intuition</b>:</h4>Like a instance member, "belongs to" an outer class instance.<br /><h4 style="text-align: left;">Constructor:</h4><pre class="prettyprint" style="text-align: left;">OuterClass.InnerClass innerObject = outerObject.new InnerClass();<br /></pre>Consequences:<br />&nbsp; &nbsp; Enclosing Class Access:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Direct access to all outer class members. Just like any method in outer class.<br />&nbsp; &nbsp; Members:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can NOT define any static members. Since it is associated with an instance.<br /><h4 style="text-align: left;">Usage:</h4><pre class="prettyprint">//Like a instance member, "belongs to" an outer class instance.<br />class InnerClass {<br /><br />    private String inner_instance_field = "inner_instance_field";<br /><br />    public InnerClass () {}<br /><br />    public void get_outer_member () { //can access any outer member<br />        String a = outer_static_field;<br />        String b = outer_private_static_method();<br />        String c = outer_instance_field;<br />        inner_instance_field = "";<br />    }<br /><br />    //COMPILE ERROR: no static member allowed<br />    //public interface inner_interface {};  //an interface is an effective static member<br />    //public static String get_static_instance_field () {}<br />    //private static String static_field = "static_field";<br />}</pre><h3 style="text-align: left;">2.1. Local Class</h3><h4 style="text-align: left;"><b>Intuition</b>:</h4>Defined inside a block (a method, a if block, a for loop). The scope of the class is its enclosing block. <br />A special case of inner class. Thus no static member, a rule inherited from inner class.<br /><h4 style="text-align: left;">Constructor:</h4><h4 style="text-align: left;"> Consequences:</h4>&nbsp; &nbsp; Enclosing Class Access:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Direct access to all outer class members. Just like any method in outer class. <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;But for local classes in static contexts, can only refer to static members of the enclosing class.  "Non-static member cannot be referenced from a static context" this rule always applies.<br />&nbsp; &nbsp; Members:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can NOT define any static members. EVEN IF it's inside a static block.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Only exception is for static final String/primitive. As they are stored like a constant. <br /><pre class="info">A local class can have static members provided that they are constant variables.<br />(A constant variable is a variable of primitive type or type String that is declared<br />final and initialized with a compile-time constant expression.<br />A compile-time constant expression is typically a string or an arithmetic expression<br />that can be evaluated at compile time.<br />Note: If a primitive type or a string is defined as a constant and the value is known at<br />compile time, the compiler replaces the constant name everywhere in the code with its value.<br />This is called a compile-time constant. If the value of the constant in the outside world changes<br />(for example, if it is legislated that pi actually should be 3.975),<br />you will need to recompile any classes that use this constant to get the current value.<br /></pre><br />&nbsp; &nbsp; Local Variable Access:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can access local variables or method parameters that is final.  <br /><pre class="info">A local class can use the local variables, method parameters, <br />and even exception parameters that are in its scope, <br />but only if those variables or parameters are declared final. <br />This is because the lifetime of an instance of a local class can be <br />much longer than the execution of the method in which the class is defined. <br />For this reason, a local class must have a private internal copy of <br />all local variables it uses (these copies are automatically generated by the compiler). <br />The only way to ensure that the local variable and the private copy <br />are always the same is to insist that the local variable is final.<br /></pre>Usage:<br /><pre class="prettyprint" style="text-align: left;">  <br />{<br />    class LocalClass {<br />        //can access outer member<br />        String a = outer_instance_field;<br />        String b = outer_static_field;<br /><br />        //static String c = "";  //ERROR: no static allowed<br />        //final static String d ; //ERROR: not a compile-time constant<br />        final static String d = ""; //a constant known at compile time<br />    }<br />    //static class StaticLocalClass {} //ERROR: local class cannot be static, regardless where.<br />}<br /><br />static {  //this is a static context<br />    //static class StaticLocalClass {} //ERROR: local class cannot be static, even if in static context<br />    class LocalClass {<br />        //can access outer member<br />        //String a = outer_instance_field; //ERROR: non-static cannot be referenced from static context<br />        String b = outer_static_field;<br /><br />        //static String c = "";  //ERROR: no static allowed<br />        //final static String d ; //ERROR: not a compile-time constant<br />        final static String d = ""; //a constant known at compile time<br />    }<br />}<br /><br />public void outer_instance_method(Object method_param) {<br />    String outer_instance_method_local_var = "";<br />    class LocalClass { //local class at non-static context<br />        String f = "";   //can have non-static member<br /><br />        /*<br />        A local class can have static members provided that they are constant variables.<br />        (A constant variable is a variable of primitive type or type String that is declared<br />        final and initialized with a compile-time constant expression.<br />        A compile-time constant expression is typically a string or an arithmetic expression<br />        that can be evaluated at compile time.<br />        Note: If a primitive type or a string is defined as a constant and the value is known at<br />        compile time, the compiler replaces the constant name everywhere in the code with its value.<br />        This is called a compile-time constant. If the value of the constant in the outside world changes<br />        (for example, if it is legislated that pi actually should be 3.975),<br />        you will need to recompile any classes that use this constant to get the current value.<br />         */<br />        //final static Object d = new NestedClassTest(); //ERROR: this is not a compile time constant<br /><br />        final static int e = 5;  //need to be string or int. need to know it at compile time<br /><br />        String a = outer_instance_field;<br />        String b = outer_static_field;<br />        String c = outer_instance_method_local_var; //outer_instance_method_local_var need to be final<br /><br />        Object abc = method_param; //can access final method param<br /><br />        private void local_method() {<br />            Object d = method_param; //can access final method param<br /><br />            //outer_instance_method_local_var = "";  //ERROR: need to be final<br />            //method_param = ""; //ERROR: need to be final<br /><br />            outer_instance_field = ""; //no problem interact with outer class field<br />            outer_static_field = "";   //can access static or non-static<br /><br />            LocalClass a = new LocalClass();<br />        }<br />    }<br /><br />    //a local class is valid only within the scope defined by its enclosing block.<br />    //But the local class has access to outer class members.<br />    LocalClass a = new LocalClass();<br />    /*<br />    A local class can use the local variables, method parameters,<br />    and even exception parameters that are in its scope,<br />    but only if those variables or parameters are declared final.<br />    This is because the lifetime of an instance of a local class can be<br />    much longer than the execution of the method in which the class is defined.<br />    For this reason, a local class must have a private internal copy of<br />    all local variables it uses (these copies are automatically generated by the compiler).<br />    The only way to ensure that the local variable and the private copy<br />    are always the same is to insist that the local variable is final.<br />     */<br />    outer_static_field2 = a; //here, a local class instance outlives local method scope<br />    a.local_method();<br />}<br /></pre><h3 style="text-align: left;">2.2. Anonymous Class</h3><h4 style="text-align: left;"><b>Intuition</b>:&nbsp;</h4>&nbsp;Local class without a name.<br /><h4 style="text-align: left;">Constructor:</h4><pre class="prettyprint">//implementing interface<br />new InterfacName () { /*class-body*/ }<br /><br />//extending class<br />new ClassName ( [ argument-list ] ) { /*class-body*/ }<br /></pre>Consequences: &nbsp; &nbsp;<br />&nbsp; &nbsp; Enclosing Class Access:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Direct access to all outer class members. Just like local class. <br />&nbsp; &nbsp; Members:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can NOT define any static members. <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Only exception is for static final String/primitive. As they are stored like a constant. <br />&nbsp; &nbsp; Local Variable Access:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can access local variables or method parameters that is final. <br />Usage:  <br /><pre class="prettyprint">class Executor {public static void execute(Runnable r){r.run();r.run2();}}<br />class BaseTracker {public void track(Object obj){}}<br />interface Runnable {<br />    void  run();  //abstract method<br />    default void run2(){};  //extension method<br />}<br /><br />class Tracker extends BaseTracker{<br />    private String outer_class_var = "";<br /><br />    //anonymous class<br />    public void track1(final Object event) {<br />        Executor.execute(new Runnable() {<br />            //static String a = ""; //ERROR: no static allowed<br />            final static String b = ""; //constant OK<br />            String c = outer_class_var;   //compiler create a package-level getter for enclosing class's private variables<br /><br />            @Override<br />            public void run() {<br />                Tracker.super.track(event);  //Tracker.super refers to enclosing class's super class<br />                //super.track(event); //ERROR: cannot resolve<br />                //BaseTracker.track(event);  //ERROR: can only reference static method<br />            }<br />        });<br />    }<br /><br />    //local class<br />    public void track2(final Object event) {<br />        //anonymous class translated into local class<br />        class TrackerRunnable implements Runnable {<br />            //@Override<br />            public void run(){<br />                //super need to be in a non-static context<br /><br />                System.out.println(this.toString()); //this refers to the TrackerRunnable instance<br />                System.out.println(super.toString()); //super defaults to the same instance!!!<br /><br />                Tracker.super.track(event);  //Tracker.super refers to BaseTracker<br />                Runnable.super.run2(); //Runnable.super refers to Runnable<br /><br />                //super.track(event); //ERROR: cannot resolve, super refers to this<br />                //BaseTracker.track(event);  //ERROR: can only reference static method, .track() is instance method<br />            }<br />        }<br />        Executor.execute(new TrackerRunnable());<br />    }<br /><br />    public static void main(String... args) {<br />        new Tracker().track2("");<br />    }<br />}<br /></pre>Reference: <a href="http://docstore.mik.ua/orelly/java-ent/jnut/ch03_13.htm">Java in a Nutshell: How Inner Classes Work</a><br /><br />TODO:  final keyword:<br />1. class - cannot be subclassed<br />2. method - cannot be overridden<br />3. variable - cannot be assigned more than once<br />Java memory model: stack, heap,<br />synthetic copy<br />dp/dip 是个长度单位。  </div>
